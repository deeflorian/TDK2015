\chapter{Runtime verification of embedded systems}
\label{chap:runtime_verification}

\section{Intro}
A statechart language was created to enable the high level design, verification, and monitoring of complex systems. The aim was to use a simple and straightforward syntax to keep the languageâ€™s learning curve gentle. Statecharts were chosen as they are used widely for modeling in various branches of engineering.
\section{Goal}
#####TODO
  \subsection{Simple, generic, useable}
#####TODO
  \subsection{Verification}
#####TODO
  \subsection{Monitor generation}
#####TODO
\section{Why not upgrade previous solutions}
#####TODO
Validation software is... 
Many software is available for code generation. Unfortunately the available solutions either provide poor quality code or have a limited syntax, thus making the creation and understanding of the models more time consuming than necessairy. Our approach was to generate easily readable, extendable, object oriented code that can run in a limited resource environment.
  \subsection{Parametric statechart declaration}
The language allows a specification to consist of multiple statecharts. This feature led to of the main strengths of the language: the definition of statechart templates, which can be parametrically instantiated multiple times. This results in short descriptions for otherwise complex, homogenious systems. Statechart parameters can be of any type supported by the TTMC::Constraint language. Separate statecharts can communicate with each other using signals or global variables.
  \subsection{Parametric signals}
Signals can also be parameterized with any integer type variable. These parameters then can be used to discriminate between signals with the same name, which also results in more readable code, allowing transitions to use the same signal as their trigger.
\section{Statechart specification language for enginneering models}
#####TODO Brackets are used to indicate the scope of each block. Naming conventions, allowed names, etc... Scoping for named instances. Timing of transitions, when they are taken, etc.
  \subsection{The specification}
A specification can consist of multiple statecharts. Statechart definitions must be in the form of \\statechart NAME(...) { ... }\\, where the \\{ ... }\\ part contains the description of the statechart. The braces are optional and are only needed for the parameters of statechart templates. For statechart declarations, the description can be omitted. Each specification must have at least one defined statechart. Parameterized statecharts can be created from existing templates by providing a value for each parameter.
  \subsection{Variables}
Variables can either be global (accessible to all statecharts) or local (bound to a single statechart in which they were declared). Many types are supported chapter{ characters, integers, doubles, etc... For a complete list, see \\appendix4TTMCConstraint\\. The variable declaration is in the form of \\global|local var NAME : TYPE\\, where global or local denotes the scope of the variable.
  \subsection{Expressions and assignments}
Variables can be used in expressions. Expressions can have an arbitrarily complex structure within the limits of the \\TTMC::Constraint\\ language. This allows for, among others, the use of array indexing, parenthesis, and common operators in programming languages (+, -, *, /, modulo, ...). Assignments left hand sides are a single variable while their right hand side is an expression. Logical expressions using operators are also available (for example expressions using comparison operators). Each expression is a mixature of variables, constants, and operators. For a full reference, see \\TTMC::Constraint\\.
  \subsection{Parametric signals}
Statecharts can communicate with the outside world and each other using signals. As such, these signals are declared directly in the specification and not in the statecharts themselves. Signals can be used with a single integer parameter (which can be either a constant or a variable). This allows for much simpler syntax when dealing with communication, as a statechart can raise a signal and pass a value simultaneusly. It also leaves room for a later expansion to a token based automata with reentry.
  \subsection{Timeouts}
Raising a signal can be offset by a certain amout of time. For the formal model, the value is measured in units, for the monitors, this value corresponds to the milliseconds elapsed since the timeout was set. Timeouts and signals can be used interchangeably.
  \subsection{Entry and exit actions}
#####TODO
  \subsection{Regions}
Statecharts are structured by the usage of regions. Regions have both states and transitions, and play a fundament part in the scoping of elements. The syntax for regions is: \\region NAME { ... }\\ Each region must contain at least an initial state for the model to be valid.
  \subsection{Transitions}

    \subsubsection{Transition actions}
    \subsubsection{Transition guards}
    \subsubsection{Transition timing}
  \subsection{State nodes}
Each region can contain multiple state nodes. A state node can either be a state or a pseudo state. States create the base structure of the model, while pseudo states help to describe the functionality. Pseudo states can either be an initial, a fork, a join, or a choice state.
    \subsubsection{States}
States can either be atomic states or composite states. An atomic state is a state which does not contain inner regions. All states can contain entry and exit actions. Composite states contain one or more inner regions, each with at least an inner initial state. A state's parent is it's containing region's containing state, or if that region does not have containing state, the region's containing statechart. The inverse of this relation is called of it's child. Composite states help maintaining a clean model by the introduction of hierarchy, allowing common actions to be described in a parent state.
    \subsubsection{Fork and join states}
A fork state is a pseudo state that has a single 
    \subsubsection{Composite state}
    
    
#####TODO Entry actions can be assignments and signal raises.


  \subsection{Error states, propagation}
\section{Formal representation}
  \subsection{Signals}
  \subsection{Variables}
  \subsection{Expressions}
  \subsection{States}
  \subsection{Timouts}
  \subsection{Transitions}
\section{Accepting monitor}
  \subsection{Variables}
  \subsection{Signals}
  \subsection{Timeouts}
  \subsection{States}
  \subsection{Transitions}
\section{Implementation}
  \subsection{Other utility classes}
  \subsection{Timing (clock of the monitor)}
  \subsection{Interface, signal pushing}
\section{Summary}
