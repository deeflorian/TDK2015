\chapter{Runtime verification of embedded systems}
\label{chap:runtime_verification}
A statechart language was developed to support the high level design, verification, and monitoring of complex systems. The aim was to use a simple and straightforward syntax to keep the learning curve of the language gentle. The formalism of statecharts was chosen as it is a widely used modelling tool in various branches of engineering.\\
The goal was to create a formal statechart language that resembles languages already used in engineering practices. This would shorten the learning process and enable formal verification of the resulting models, which could aid the development of highly dependable safety critical systems with lower design and maintenance costs.
\section{Advantages of statecharts}
Statecharts build on the concept of state machines and are highly visual. Statecharts can be easily used for abstraction, providing a generic way to describe small processes or whole systems. Compositional modelling is possible as states can be refined.
  \subsection{Verification}
The development of safety critical systems require extensive testing efforts. While testing can detect most of the system's faults, it can't guarantee that all of the errors are found. On the other hand, the application of formal methods can guarantee that all of the (formally) specified requirements are met.
  \subsection{Monitor generation}
Formal verification methods verify a model, not the developed system itself. Specification or hardware errors can also occur. Using runtime verification one can detect such malfunctions at runtime so that the system can handle the error and avoid critical failures. Monitors are also capable of providing traces that can unravel the propagation of faults. Therefore, the statechart language provides tools for marking erroneous states and transitions, and is capable of generating monitors that track the system's state through an interface that receives signals. These monitors simulate the statechart based model of the system, which makes it possible to use them for error reporting. The generated component can also be used as a skeleton for smaller programs.
\section{New features}
Many software is available for code generation and verification based on statecharts. Unfortunately the available solutions for verification and modelling provide limited syntax, and code generation usually results in poor quality code. Both leads to longer development, harder maintenance, and higher costs. Our statechart language supports the verification of statecharts with parametric signals and timers, and enabling the creation of template statecharts that can be instantiated as parametric statecharts. For monitor generation, our approach was to generate easily readable, extendible, object oriented code, that can run in environments with limited resources -- primarily embedded systems.
  \subsection{Parametric statechart declarations}
The language allows a specification to consist of multiple statecharts. This feature led to of the main strengths of the language: the definition of statechart templates, which can be instantiated parametrically. This results in short descriptions for otherwise complex, but homogeneous systems with many similar components. Statecharts can be parametrized by values of well known data types. Separate statecharts can communicate with each other using signals or global variables.
  \subsection{Parametric signals}
Signals can also be parametrized with integer variables. These parameters can then be used to discriminate between raises of the same signal, which also results in more readable code by allowing transitions to use the same signal as their trigger when their functionality is similar.
\section{Overview}
For a brief overview of the language, see the example specification below.
\begin{verbatim}
specification exSpec {
  global gVar : integer
  signal exSig
  statechart exStc {
    local lVar : integer
    region exReg {
      initial state exInit
      state exComplex {
        region exInner {
          initial state exInit2
          state exInner
          transition from exInit2 to exInner on exSig / assign lVar := lVar + 1
        }
        region exInner2 {
          initial state exIdle
        }
      }
      state [Error] exSimple
      transition from exInit to exComplex / assign gVar := 3, assign lVar := 0
      transition from exComplex to exSimple [gVar = 3] / raise exSig(2)
    }
  }
}
\end{verbatim}
The description of the whole system is enclosed in a specification, which can have multiple statechart, signals, and global variable declarations. Each statechart consists a region and an optional number of local variable declarations. Regions encapsulate states and transitions. Each region must have at least an initial state. A state itself can have an arbitrary number of inner regions, which will run in parallel. States can also have entry and exit actions associated with them. Transitions must have a source and a target state, and can have triggers, guard conditions, and actions. States and transitions can be marked with an error token to indicate that the execution of the transition or the activation of the state is erroneous behaviour. Actions can be variable assignments and signal raises.
\section{Language syntax}
  \subsection{Specification}
Modelling the whole system as a single statechart would result in an overly complex statechart. Systems can usually be described as independent components that can communicate with each other. Therefore, an enclosing specification is used for the description of the whole system, within which statecharts can be declared as (mostly) independently operating components. Each specification can contain multiple statecharts. To enable communication between statecharts, global variable declarations and signal declarations are placed in the specification itself.
  \subsection{Statecharts}
The syntax for statechart definition is in the form of:
\\\\\verb!statechart exStc(!\textit{params}\verb!) {...}!\\\\
where \textit{params} is an optional parameter list, and \verb!{...}! contains the description of the statechart itself. The braces can be omitted if no parameters were specified. Parametrized statecharts can be created from existing templates by providing a value for each parameter and omitting the description. Definitions without parameters are treated as an instantiation of the statechart. A specification must contain at least one instantiated statechart.
%%%%% TODO continue fixing from this point%%%%%
  \subsection{Regions}
Statecharts are structured by the use of regions. At the root of every statechart, a region encloses all of the states. State can have an arbitrary number of inner regions. This plays a fundamental part in the scoping of elements. A region can have both states and transitions. The syntax for regions is:
\\\\\verb!region NAME {...}!\\\\
where the \verb!{...}! is the definition of the region's contents. Each region must contain at least an initial state for the model to be valid.
  \subsection{State nodes}
Regions can contain multiple state nodes. A state node can either be a state or a pseudo state. States create the base structure of the model, while pseudo states help to describe functionality. Pseudo states can either be initial-, fork-, join-, or choice states.
    \subsubsection{States}
States can either be atomic states or composite states. An atomic state is a state which does not contain inner regions. All states can contain entry and exit actions, which are executed when entering or exiting the state. Composite states contain one or more inner regions, each with at least an initial state. A state's parent state is it's containing region's containing state, or if the region does not have containing state, the region's containing statechart. Composite states allow users to maintain a clean model by the introduction of hierarchy, and the ability to describe common actions in the parent state.
    \subsubsection{Initial states}
Initial states can be found in all regions - if the region's containing state is entered, these inner states become active.
    \subsubsection{Choice states}
Choice states are pseudo states whose outgoing transitions have exactly one guard condition evaluating as true at all times. Choice states let the user create tree-like transition structures with simple guards conditions on each level, instead of rewriting similar, complex guard conditions using a single transition level. This usually results in more readable, modifiable, and expressive models.
    \subsubsection{Fork and join states}
A fork state is a pseudo state that has a single incoming transition and any number of outgoing transitions. The outgoing transitions cannot have triggers, guards, or actions associated with them. If the incoming transition fires, all the outgoing transitions fire as well, and the fork state itself is not entered. This results in the simultaneous activation of multiple states.
A join state is a pseudo state that has a single outgoing transition and multiple incoming transitions. The incoming transitions cannot have triggers, guards, or actions associated with them. The outgoing transition is enabled when it's guard is true and all the incoming transitions' source states are active. Triggers can be declared on the outgoing transition.
  \subsection{Transitions}
Transitions describe the possible state changes. A transition can only occur if the source state is active. After the transition fires, the source state becomes inactive and the target state active. Furthermore, a transition can have a trigger, a guard condition, and an arbitrary number of actions associated with it.
    \subsubsection{Transition triggers}
Transitions with triggers can only fire when one of the triggering signals arrive. Defining triggers is optional. Enabled transitions without a trigger occur on the next timestep after the source state becomes active.
    \subsubsection{Transition guards}
Transitions can have guard conditions, which are expressions that evaluate to a boolean value. If the guard condition evaluates to true, the transition is enabled, otherwise it is blocked.
    \subsubsection{Transition actions}
A transition can have any number of actions associated with it. These actions are performed when the transition fires.
  \subsection{Actions}
Raising signals with or without a timeout, and variable assignments are called actions. They represent operations that might result in a change of the model's state.
  \subsubsection{Parametric signals}
Statecharts can communicate with the outside world and each other using signals. These signals are declared directly in the specification. Signals can be used with a single integer parameter (which can be either a constant or a variable). This allows much simpler syntax when dealing with communication, as a statechart can raise a signal and pass a value simultaneusly. It also leaves room for a later expansion to a token based automata with re-entry.
A parametric signal can be declared like:
\\\\\verb!signal NAME(!\textit{param}\verb!)!\\\\
where \textit{param} is an integer-type variable declaration. A signal can be referenced multiple times, but only one transition may be taken per statechart for a raised signal. This results in a clearer model.
  \subsubsection{Timed signals}
Raising a signal can be offset by a certain amount of time. Apart from their delayed nature, timeout- and signal references can be used interchangeably. A timeout can be raised by:
\\\\\verb!raise NAME after !\textit{amount}\\\\
where \verb!NAME! is the name of the referenced signal and \textit{amount} is the number of timesteps before the signal is raised.
  \subsubsection{Variable assignments}
Variable assignments can be expressed with the syntax:
\\\\\verb!assign !\textit{lhsExp}\verb! := !\textit{rhsExp}\\\\
where \textit{lhsExp} has to evaluate to an assignable reference, such as a variable or an array element. The \textit{rhsExp} can be any valid expression.
  \subsection{Timing of transitions and actions}
Transitions are fired one by one. The firing of a transition means that the triggering signal is consumed. This can result in non-deterministic runs if two transitions share the same trigger and can be enabled simultaneously. Such models can be created but should be avoided, as the order of the transitions is not guaranteed. Actions related to the current transition being taken are all executed in a single step.
  \subsection{Signalling errors, error propagation}
States and transitions can be labelled as errors. The syntax is:
\\\\\verb!state/transition [Error label] ...!\\\\
where the \verb!label! is a description given by the user. This is only used for the generation of error messages in the monitor.
  \subsection{Expressions}
Variables can be used in expressions. Expressions can have an arbitrarily complex structure within the limits of [TODO-ref]. This allows, just to mention a few, the use of array indexing, parenthesis, and common operators in programming languages such as \verb!+!, \verb!-!, \verb!*!, \verb!/!, etc. Assignments' left hand sides must reference a single variable while their right hand side is an expression. Logical expressions are also available (for example expressions using comparison operators). Each expression is a mixture of variables, constants, and operators. For a full reference, see [TODO-ref].
  \subsection{Variables}
Variables can either be global (accessible to all statecharts) or local (bound to a single statechart in which they were declared). Many types are supported, like characters, integers, and doubles. For a complete list, see [TODO-ref]. Variable declarations are in the form of:
\\\\\verb!global|local var NAME : TYPE!\\\\
where global or local denotes the scope of the variable, and \verb!TYPE! is one of the supported types.
\section{Formal representation}
To enable formal verification of the defined systems, a mapping tool was developed that can transform specifications to a transition system. This means that the complex concepts of the model have to be flattened out. The transition system used has the following capabilities:
\begin{itemize}
  \item multiple independent transition systems can be defined
  \item these systems are enclosed in a specification
  \item transition systems can use local and global variables
  \item the state of a transition system can be defined as a vector of all referenced variables
  \item multiple states can be represented by expressions that restrict certain variables' values and leaves the rest of them unbound
  \item such restrictions are logical formulas with variables, that may use =, <, >, and, or, etc...
  \item transition systems have transitions that represent changes of state using the referenced variables previous and current values
\end{itemize}
  \subsection{Specification}
The specification of the statechart language is mapped to the specification of the transition system. Global variables cannot be declared in the specification itself, they must be present in all of the transition systems that use them. Signals will be mapped to global variables.
  \subsection{Statecharts}
Each statechart is mapped to a separate transition system. As transition systems are treated like they are running in parallel, this models the original behaviour of the statecharts - they define systems that can communicate with each other but are running independently. Local variables have the same representation and need no conversion.
  \subsection{Regions}
A transition system does not support hierarchical structures -- they are flat models. This means that all regions, states, and transitions inside a statechart are mapped directly into a transition system.
  \subsection{States}
States are represented as boolean variables that signal whether the state is currently active or not. As entry and exit actions are unknown concepts in a transition system, these actions are propagated to all of the incoming and outgoing transitions of the state. This way any transition that would result in the entering or exiting of the state executes the appropriate actions.\\
Composite states entry and exit actions and their incoming and outgoing transitions are propagated to the atomic states inside them. This means that only atomic states are represented in the transition systems.
  \subsection{Transitions}
Transitions between states are transitions in the formal model too. For a transition to be enabled, guard conditions has to evaluate to \verb!TRUE! for the current state of the system, the source state has to be currently enabled (meaning that the source state's boolean variable is true), and the transition should have no trigger or the triggering signal's boolean variable has to be true (representing that it was raised). When the transition fires in the formal model, the exit actions, the actions associated with the transition, and the needed entry actions of the appropriate states occur.  
  \subsection{Signals}
Signals can be used for communication between statecharts. As such, each transition system that references a signal need to be able to check whether the signal was raised. Therefore, in the formal model signals are represented as a set of global boolean variables. The variable is true if the signal has been raised since the previous timestep was taken. As each statechart referencing the signal might react to it by the firing of a transition triggered by the signal, a separate global boolean is used for each transition system. Since each signal can only trigger a single transition inside any given statechart, more complexer solutions are not needed. The parameters of the signals are stored and can be referenced as global integer variables.
  \subsection{Timeouts}
Timeouts are signals that are raised with an offset in the time domain. Handling timeouts in a transition system is a well researched area (TODO-ref.: Transition Systems in SAL - Dutertre, Sorea). A separate timing system is created as a transition system to generate simulate timesteps. The system has a variable that stores the current time and each signal has a helper variable that represents when the signal has to be raised. If a timeout is set, the offset of the timeout is added to the current time and this value is assigned to the helper variable. The timing system has a constantly enabled transition which increments the current time if no timeout can occur. For each timeout a transition is defined that is enabled when the current time is equal to the time stored in the helper variable. When this transition happens, the signal is raised. The helper variables are set to -1 by default to prevent false signal raises based on timeouts.
  \subsection{Variables and expressions}
Variable types are the same as in the statechart model. Global variables remain global ones, and local variables that are declared inside statecharts are mapped to local variables inside systems. Expressions need no further flattening as the expression library used by the transition system language and the statechart language is the same.
  \subsection{Verification}
The verification of the mapped system is based on LTL expressions. These can be defined at the end of the specification. (TODO?)
\section{Accepting monitor}
Runtime verification of safety critical components can be done by a monitoring component that checks the current state. This can result in significantly smaller monitors than the component itself as multiple levels of abstraction can be used as long as the error states remain distinguishable. To make runtime verification possible, a lightweight \verb!C++! monitoring component can be generated from the described statecharts. This monitor can then be deployed to run in parallel with the safety critical component. The monitor has an interface to accept signals from the system, enabling the simulation of the desired behaviour. Should a state or a transition that has been marked as an error be reached, the monitor's error signalling interface is called. The user can implement this interface to hook the generated error messages to other monitors and components running the safety, or error handling logic of the system. This function makes hierarchic runtime verification possible.
  \subsection{Specification}
A specification consists of separate statecharts. To simplifying their handling, a class was created called \verb!StatechartRegistry! that can automatically iterate through each statechart and update their state one timestep at a time. This class is also responsible for the initialization process of the monitor. The name of the class does not represent the whole specification as global variables and signals are handled by utility classes.
  \subsection{Statecharts}
Statecharts are represented as classes with lists of all their transitions, states, and currently active states. Local variables are mapped to global ones for unified usage. The statecharts' names are also stored for the error signaling process. Statecharts have functions for calculating their enabled transitions, taking enabled transitions, and maintaining the list of active states.
  \subsection{State nodes}
State nodes represent states, initial states, join states, and fork states. Their mapping highly depends on their type.
    \subsubsection{States}
Atomic or complex states are represented by named objects. All of these objects are derived from the \verb!State! class. This object represents a state that has no entry and exit actions. If a state has entry or exit actions, a child class is generated where the appropriate entry and exit actions are represented as overrides for the \verb!Entry()! or \verb!Exit()! function. Classes are instantiated using the states' fully qualified names.
    \subsubsection{Initial states}
Initial states are mapped to \verb!State! objects. This general class also has a boolean variable that is set to \verb!TRUE! for initial states.
    \subsubsection{Fork, join, and choice states}
Fork, join, and choice states are not represented in the monitoring object. These state nodes modify the behaviour of transitions, and are handled when mapping transitions.
  \subsection{Transitions}
Transitions are represented as objects connecting two states. An instance of the generic \verb!Transition! class has an \verb!isEnabled()! function that always returns true, and an empty \verb!action()! function that simply returns. A null-initialized list reference is also present that can point to a list of states. The list itself is only created for fork and join states to minimize memory usage. The triggers of the transitions are handled in a separate mapper class and are play no role in the creation of transition objects.
    \subsubsection{Simple transitions}
Transitions without actions or guards can be instances of the generic \verb!Transition! class, while transitions with guard conditions or actions are it's children with overloaded functions. Simple transitions have one source and one target state specified when instantiating them.
    \subsubsection{Transitions of choice states}
Transitions from, and to choice states are handled by a statechart preprocessor that unfolds choices to simple transitions with the needed guard conditions to conserve functionality. The call to the preprocessor is the first step of the monitor generation.
    \subsubsection{Transitions of fork and join states}
Incoming and outgoing transitions of a fork state are mapped to a single transition with a target state reference of null. The fork's outgoing transitions are stored in the separate list of state references. A join state's transitions are also mapped to a single transition with a source state reference of null. The fork's incoming transitions are stored in the separate list of state references.
  \subsection{Signals}
Signals are represented as instances of the \verb!Signal! class, which is a class that describes a named object containing an integer value. Raising a signal means creating an instance with the appropriate name and parameter and putting it in a queue for processing in the next timestep. Signals with a timeout are stored in a separate row until they should be raised. Parameterless signals are signals with a parameter of a predefined, unused value.
  \subsection{Actions}
    \subsubsection{Raising signals and timeouts}
Signals can be raised by creating a signal object and placing it in the queue for arrived signals. Timeouts are signal raises that will occur in the future. When raising a timeout, the appropriate signal is created and put in a queue that holds pairs of signals and timestamps. The timestamp represents when the signal should go off.
    \subsubsection{Variables and expressions}
The assignments and expressions that can be used in the statechart language are a subset of the C++ language, so the mapping between the statechart language and the generated monitor adds no restrictions and require no extra constructs.
  \subsection{Variables}
The variable types of the statechart language are plain old data types in C++. Local variables are converted to global variables with fully qualified names. This allows a variable container class to be created which holds all of the variables and allows unified usage.
\section{Implementation}
The implementation of the monitoring component can raise many questions about timing. To generate working, and easily usable code additional helper classes and extra functions for the already described ones are required. The most important ones are described in this section. It should also be noted that the generated \verb!C++! code heavily relies on the new features of \verb!C++11!.
  \subsection{Timing related issues}
The generated monitoring component will run on a real hardware. This means that the system can only take a limited number of transitions per second. Aiming for a lightweight component, there is a settable sleep and timeout period. The default implementation of the utility classes enables the user to set this period with millisecond precision.\\
For each timestep, the monitor:
\begin{enumerate}
  \item wakes up
  \item checks the future signals queue for elapsed signals
  \item puts such signals in the arrived signal's queue
  \item selects a statechart
  \item checks for transitions that can be fired
  \item fires one of them and apply the related actions
  \item updates the list of active states
  \item repeats from step 5 until no transition is enabled
  \item repeats from step 4 until no statechart is left
  \item goes to sleep for the set sleep period
\end{enumerate}
Raising signals while taking a transition puts the raised signal in a separate row that will be switched for the currently used one before going to sleep again. This means that only those transitions are taken whose triggers arrived in the queue before waking up. A signal with a timeout of \verb!x! means that the signal will be raised on the next awakening after \verb!x! milliseconds will have passed.
  \subsection{Utility classes}
A few utility classes are needed to keep the structure of the code more readable, or to make the functionality more customizable. The most important classes are listed under this section.
    \subsubsection{SignalRegistry}
A class called \verb!SignalRegistry! was introduced to create a thread-safe wrapper for signals, and a maintainer of signals with timeouts.
    \subsubsection{VariableRegistry}
All variables are treated as global variables. For availability and enclosure, we choose to create a centralized class with static variables resembling each variable found in the original statechart descriptions.
    \subsubsection{Timestamp}
For easily replaceable timing settings, the handling of timing properties is done by a separate \verb!Timestamp! class. The default implementation is to use millisecond-resolution functions and classes of \verb!std::chrono!.
  \subsection{Signal pushing}
The monitoring component starts in a separate thread. This means that calling the \verb!start! function will only block the current thread as long as the initialization process is running. After starting the monitor, the \verb!SignalRegistry::SignalArrived(!\textit{param}\verb!)! function can be called to inject a signal with the name \textit{param} into the system from the outside world. Naturally, the \verb!SignalRegistry! class is thread-safe.
  \subsection{Error signalling}
The \verb!OnError(!\textit{param}\verb!)! function is called upon reaching an error state or transition. The \textit{param} is equal to the specified message defined in the statechart model, or in case of states that have not defined a message, the fully qualified name of the error state. The function should be modified by the user to implement the necessary error signalling steps of the system.
